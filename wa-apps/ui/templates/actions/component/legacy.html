{$_title = "Сценарии перевода приложений на wa-2.0.css"}
{$wa->title($_title)}

<h1>Три сценария перевода приложений на <code>wa-2.0.css</code> для разработчиков</h1>

<blockquote class="highlighted caution">
    Информация на этой странице — только для разработчиков приложений и плагинов, работающих на основе <code>wa-1.3.css</code> (старой  дизайн-системы 2011—2020).
</blockquote>

<p>Во фреймворке <b>одновременно доступны обе дизайн-системы</b>, и приложение будет работать в той системе, в которой оно задекларировало — либо в старой, либо в новой. Разработчик каждого приложения на свое усмотрение решает, когда и как переводить его с wa-1.3.css на wa-2.0.css. А чтобы вам не пришлось «костылять» в шаблонах и CSS-правилах <code>if 1.3 / if 2.0</code>, можно одновременно поддерживать и старый, и новый варианты интерфейса в разных независимых копиях шаблонов — так, что пользователь сам решит, каким вариантом пользоваться.</p>

<h3>Разработчикам приложений (<code>wa-apps/APP_ID/</code>)</h3>

<p>В конфиге каждого приложения <code>APP_ID/lib/config/<b>app.php</b></code> мы вводим возможность указать (задекларировать), какая версия интерфейса поддерживается:</p>

<ul class="separated">
<li><code>'ui' => '2.0'</code>: означает, что приложение работает только в новом интерфейсе 2.0. В этом случае переход обратно на старый интерфейс даже не будет предлагаться. Показывается только новый интерфейс и новая обвязка.</li>
<li><code>'ui' => '1.3'</code>: в версиях Webasyst 2.0.0 и 2.X.0 все останется без изменений, но начиная с версии 2.Y.0 (примерно когда Shop-Script начнет работать в новом интерфейсе), фреймворк для этого приложения покажет сообщение вида «Это приложение не поддерживает новый интерфейс. Скоро все пропадет. Свяжитесь с разработчиком %s». Включить wa-2.0.css-интерфейс в этом приложении нельзя, но это предупреждение будет висеть постоянно начиная с версии фреймворка 2.Y.0.</li>
<li><code>'ui' => '1.3, 2.0'</code>: переключатель режима интерфейса предложит «Включить новый интерфейс (бета)» и «Вернуться в старый интерфейс». Пользователь сам выберет нужную опцию.</li>
<li><code>'ui' не задан</code> (так будет у всех текущих приложений, которые не предприняли никаких действий): в версии Webasyst 2.0.0 — все без изменений, никаких переключений интерфейса, работает вариант 1.3. Начиная с версии Webasyst 2.X.0 (не 2.Y.0!) поведение будет таким же, как для варианта <code>'ui' => '1.3, 2.0'</code> — появится выбор «Включить новый интерфейс (бета)» и «Вернуться в старый интерфейс». Разработчик должен будет либо переводить все на новый интерфейс, либо включить <code>'ui' => '1.3'</code>.</li>
</ul>

<blockquote>Крайне важно, что для всех приложений, не предпринявших мер по переходу или обновлению app.php, сработает последний вариант (а не 'ui' => '1.3'), потому что именно в этом случае пользователи будут «пинать» разработчика по поводу переводу приложения в новую версию бекенда. Для разработчика это важнейший стимул. Либо переводи, либо уходи.</blockquote>

<p>Такое нововведение в конфиге приложения открывает для разработчика приложения следующие сценарии его перевода на новый интерфейс:</p>

<ol class="separated">
    <li><b class="black highlighted">Агрессивный</b>: поставить в конфиге <code>'ui' => '2.0'</code> и переводить на новый интерфейс. На старый интерфейс, тем самым, «забив» сразу (не забыв в этом случае поставить минимальное требование на версию фреймворка Webasyst >= 2.0 в <code>requirements.php</code>).</li>
    <li><b class="black highlighted orange">Депрессивный</b>: поставить <code>'ui' => '1.3'</code> и работать в старом лейауте. Ничего для нового интерфейса не делать. Но ожидайте вопросов от пользователей о поддержке нового интерфейса.</li>
    <li><b class="black highlighted green">Универсальный</b>: поставить <code>'ui' => '1.3,2.0'</code> и поддерживать некоторое время оба варианта: новый и старый.</li>
</ol>

<p>Какой вариант конфига выбрать — на усмотрение разработчика приложения. В разных случаях может быть наиболее эффективен каждый из них. Например, когда у приложения много плагинов от независимых партнеров (как в случае с Shop-Script), нельзя просто так взять и перейти на 2.0 в один момент. А если приложение маленькое — например, «Статус» — или имеющее маленькую аудиторию пользователей — например, «Задачи», — то можно сразу агрессивно переходить на 2.0.</p>

<hr>

<h4><span class="black highlighted green">Универсальный вариант</span>: <code>actions/</code> и <code>actions-legacy/</code> &#128077;</h4>

<p>Итак, есть вариант одновременной поддержки обоих режимов: <code>'ui' => '1.3, 2.0'</code>.</p>

<p>Разумеется, невозможно сделать так, чтобы один и тот же лейаут+шаблоны работали правильно и в 1.3, и в 2.0.</p>

<p>Поэтому, если разработчик хочет поддерживать в своем приложении оба вида интерфейса, то он просто создает две разных папки с шаблонами и лейаутами:
    <code>actions/</code> (<code>layouts/</code>, <code>*whatever*/</code>) автоматически включит wa-2.0.css, а <code>actions-legacy/</code> (<code>layouts-legacy/</code>, <code>*whatever*-legacy/</code>) — wa-1.3.css.</p>

<p>Вызовы <code>wa->css()</code> и <code>wa->header()</code> менять не надо. Никаких дополнительных параметров в этих методах.</p>

<p>В качестве примеров реализации универсального сценария (№3) см. приложение «Фото» и дашборд.</p>

<h4>Подробнее про экшены</h4>
<ol>
    <li>Если экшен внутри себя явно не задавал путь к файлу шаблона, т. е. не использовал метод <b><code>setTemplate</code></b>, то для версии 1.3 будут использоваться шаблоны из папки <code>actions-legacy/</code>, а для версии 2.0 — шаблоны из <code>actions/</code>. Названия шаблонов не меняются.</li>
    <li>Если же экшен внутри себя явно задавал путь к файлу шаблона, то в этом случае есть 2 варианта:
        <ol>
            <li>Исправить путь к шаблону так, чтобы он был указан относительно папки <code>actions/</code> и передать во 2-й параметр <code>is_relative</code> значение <strong>true</strong>.<br>
                <b>Например</b>, было так:<br>
                <code class="break-word">
                    $this->setTemplate("templates/actions/photo/PhotoList.html");
                </code>
                <p>Теперь можно сделать так — сформировать «относительный путь»:</p>
                <code class="break-word">
                    $this->setTemplate("photo/PhotoList.html", true);
                </code>
                <p>В таком случае поиск новых шаблонов будет автоматически выполняться в папке <code>actions/</code>, старых — в папке <code>actions-legacy/</code>.</p>
            </li>
            <li>Либо использовать проверку версии UI с помощью <code>wa()->whichUI($app_id|&lt;<i>skip</i>&gt;)</code> и самому подключать нужный шаблон. При этом второй параметр в <b>setTemplate</b> передавать не надо (будет использоваться по умолчанию значение <code>is_relative=<strong>false</strong></code>).</li>
        </ol>
    </li>
</ol>
<p>Классы лейаутов (унаследованные от <b>waLayout</b>), аналогично экшенам, ищут файлы шаблонов для версии 1.3 в папке <code>layouts-legacy/</code>, для версии 2.0 — <code>layouts/</code>.</p>

<h3>Разработчикам плагинов</h3>

<p>Нужно узнать у разработчика приложения, как и когда он переводит свой продукт на новый интерфейс. Затем в коде плагина можно применить такой же сценарий перехода и с помощью <a href="{$wa_app_url}component/whichui/">хелпера $wa->whichUI()</a> узнавать, какой интерфейс в данный момент включен — 1.3 или 2.0.</p>
<p>Экшены плагинов работают так же, как и экшены приложений. Все, что было сказано в пункте «Подробнее про экшены», верно и тут.</p>
<p>Внутри основного класса плагина, как и в любом другом месте, можно воспользоваться методом <code>wa()->whichUI($app_id|&lt;<i>skip</i>&gt;)</code>.</p>
<p>Также внутри класса плагина становится доступным метод <code class="break-word">protected function renderTemplate($scope, $template_path, $assign = [], $cache_id = null)</code>.</p>
<p><b>Пример его использования</b></p>
<p>
    В плагине <b>blog/plugins/favorite</b> вызываем<br>
    <code class="break-word">$this->renderTemplate('misc', $template, $assign, true);</code><br>
    В данном случае для версии 2.0 будут использоваться шаблоны из <code>templates/misc/</code> (внутри файловой структуры плагина, разумеется), а для версии 1.3 — из <code>templates/misc-legacy/</code>.
</p>

<h3>Разработчикам виджетов</h3>

<p>Контрольная панель Webasyst поддерживает обе версии интерфейса: и 1.3, и 2.0. Поэтому и в виджете можно точно так же, с помощью <a href="{$wa_app_url}component/whichui/">хелпера $wa->whichUI()</a>, узнать, какой интерфейс в данный момент включен в бекенде пользователя.</p>
<p>Основной класс виджета наследуется от класса <code>waWidget</code>, который, в свою очередь, наследуется от <code>waActions</code>, на который распространяется все, что было сказано выше в разделе «Подробнее про экшены».</p>

<h3>Разработчикам тем дизайна</h3>

<p>Ничего делать не надо. Все настройки из <code>theme.xml</code> (при условии использования стандартных возможностей этого файла) автоматически будут красиво показаны в новом интерфейсе.</p>

<blockquote class="highlighted green">

    <h2>Я готов! Что делать?</h2>
    <ol class="separated">
        <li>Переключите свою GitHub-копию фреймворка на ветку <code>webasyst2</code>: <a href="https://github.com/webasyst/webasyst-framework/tree/webasyst2" class="break-word">https://github.com/webasyst/webasyst-framework/tree/webasyst2</a></li>
        <li>Войдите в бекенд и в правом нижнем углу включите режим интерфейса «2.0». Не бойтесь — это ничего не сломает. Просто подключится окружение 2.0 вместо 1.3.</li>
        <li>Откройте свое приложение и посмотрите, как оно выглядит.</li>
        <li>Выберите один из перечисленных выше сценариев и начинайте действовать по <a href="{$wa_app_url}component/cheatsheet/">шпаргалке</a>!</li>
    </ol>

</blockquote>

<script>
    $.wa_ui.title.set({$_title|json_encode});
</script>
